{"ast":null,"code":"/**\r\n * Organizes graph data into a hierarchical structure for visualization\r\n * @param {Object} data - The raw graph data\r\n * @returns {Array} - Array of organized cluster objects\r\n */\nexport function organizeDataForVisualization(data) {\n  if (!data || !data.nodeDataArray || !data.linkDataArray) {\n    return [];\n  }\n  const nodes = data.nodeDataArray;\n  const links = data.linkDataArray;\n\n  // Extract nodes by category\n  const clusters = nodes.filter(node => node.category === \"system\");\n  const objects = nodes.filter(node => node.category === \"object\");\n  const attributes = nodes.filter(node => node.category === \"attribute\");\n\n  // Build the cluster hierarchy\n  return clusters.map(cluster => {\n    // Find objects linked to this cluster\n    const linkedObjectKeys = links.filter(link => link.from === cluster.key).map(link => link.to);\n    const clusterObjects = objects.filter(obj => linkedObjectKeys.includes(obj.key)).map(obj => {\n      // Find attributes linked to this object\n      const linkedAttrKeys = links.filter(link => link.from === obj.key).map(link => link.to);\n      const objectAttributes = attributes.filter(attr => linkedAttrKeys.includes(attr.key));\n\n      // Get harmonized attributes and check 3NF compliance\n      const harmonizedAttributeMap = {};\n      objectAttributes.forEach(attr => {\n        // Get the harmonized attribute name\n        const harmonizedName = attr.harmonisedAttribute || `Harmonised-${attr.label}`;\n\n        // Check if this attribute is 3NF compliant (from the 3nf_marker field)\n        const is3NFCompliant = attr.hasOwnProperty('3nf_marker') ? attr['3nf_marker'] === 'yes' : Math.random() > 0.5; // Simulate for demo if field is missing\n\n        if (!harmonizedAttributeMap[harmonizedName]) {\n          harmonizedAttributeMap[harmonizedName] = {\n            name: harmonizedName,\n            count: 1,\n            originalAttributes: [attr.label || 'Unknown'],\n            is3NF: is3NFCompliant\n          };\n        } else {\n          harmonizedAttributeMap[harmonizedName].count += 1;\n          if (!harmonizedAttributeMap[harmonizedName].originalAttributes.includes(attr.label || 'Unknown')) {\n            harmonizedAttributeMap[harmonizedName].originalAttributes.push(attr.label || 'Unknown');\n          }\n          // If any attribute is not 3NF compliant, mark the harmonized attribute as not 3NF\n          if (!is3NFCompliant) {\n            harmonizedAttributeMap[harmonizedName].is3NF = false;\n          }\n        }\n      });\n\n      // Convert map to array and sort alphabetically\n      const harmonizedAttributes = Object.values(harmonizedAttributeMap).sort((a, b) => a.name.localeCompare(b.name));\n      return {\n        ...obj,\n        attributes: objectAttributes,\n        harmonizedAttributes: harmonizedAttributes\n      };\n    }).sort((a, b) => (a.label || '').localeCompare(b.label || ''));\n    return {\n      ...cluster,\n      objects: clusterObjects\n    };\n  }).sort((a, b) => {\n    // Sort clusters by name\n    return (a.label || '').localeCompare(b.label || '');\n  });\n}\n\n/**\r\n * Reorganizes the graph data based on \"new_object\" attribute in CSV\r\n * This simulates AI-powered rearrangement of attributes into better object groupings\r\n * @param {Object} data - The raw graph data\r\n * @returns {Array} - Array of reorganized objects\r\n */\nexport function organizeDataForAIRearrangement(data) {\n  if (!data || !data.nodeDataArray || !data.linkDataArray) {\n    return [];\n  }\n  const nodes = data.nodeDataArray;\n  const links = data.linkDataArray;\n  const attributes = nodes.filter(node => node.category === \"attribute\");\n\n  // Create a map of new objects based on the new_object field in attributes\n  const newObjectsMap = {};\n\n  // First pass: collect all unique new objects from attributes\n  attributes.forEach(attr => {\n    if (attr.hasOwnProperty('new_object') && attr.new_object) {\n      const newObjectName = attr.new_object;\n      if (!newObjectsMap[newObjectName]) {\n        // Create a new object entry with a unique key\n        const objectKey = `new-object-${Object.keys(newObjectsMap).length + 1}`;\n        newObjectsMap[newObjectName] = {\n          key: objectKey,\n          label: newObjectName,\n          hoverLabel: `AI-generated object for ${newObjectName} attributes`,\n          category: \"object\",\n          harmonizedAttributes: []\n        };\n      }\n    }\n  });\n\n  // Second pass: group attributes by their new objects\n  attributes.forEach(attr => {\n    // Get the harmonized attribute name\n    const harmonizedName = attr.harmonisedAttribute || `Harmonised-${attr.label}`;\n\n    // Find original object the attribute belonged to\n    const originalObjects = nodes.filter(node => node.category === \"object\");\n    const originalObjectKey = links.filter(link => link.to === attr.key).map(link => link.from)[0];\n    const originalObject = originalObjectKey ? originalObjects.find(obj => obj.key === originalObjectKey) : null;\n\n    // Determine target object (use new_object field if present)\n    const targetObjectName = attr.hasOwnProperty('new_object') && attr.new_object ? attr.new_object : null;\n    if (targetObjectName && newObjectsMap[targetObjectName]) {\n      addAttributeToNewObject(newObjectsMap[targetObjectName], attr, harmonizedName, (originalObject === null || originalObject === void 0 ? void 0 : originalObject.label) || \"Unknown\");\n    }\n  });\n\n  // Convert objects map to array and organize into a single \"AI Generated\" cluster\n  const objectsArray = Object.values(newObjectsMap);\n\n  // Sort objects by name\n  objectsArray.sort((a, b) => a.label.localeCompare(b.label));\n\n  // Sort harmonized attributes within each object\n  objectsArray.forEach(obj => {\n    obj.harmonizedAttributes.sort((a, b) => a.name.localeCompare(b.name));\n  });\n\n  // Create a single cluster containing all new objects\n  const aiGeneratedCluster = {\n    key: \"ai-generated-cluster\",\n    label: \"AI-Generated Structure\",\n    category: \"system\",\n    hoverLabel: \"Objects reorganized by AI based on attribute relationships and semantics\",\n    objects: objectsArray\n  };\n  return [aiGeneratedCluster];\n}\n\n/**\r\n * Helper function to add an attribute to a new object\r\n * @param {Object} targetObject - The object to add the attribute to\r\n * @param {Object} attribute - The attribute to add\r\n * @param {string} harmonizedName - The harmonized name of the attribute\r\n * @param {string} originalObjectName - The name of the original object\r\n */\nfunction addAttributeToNewObject(targetObject, attribute, harmonizedName, originalObjectName) {\n  // Check if this harmonized attribute is already in the target object\n  const existingAttr = targetObject.harmonizedAttributes.find(attr => attr.name === harmonizedName);\n\n  // Check if this attribute is 3NF compliant (from the 3nf_marker field)\n  const is3NFCompliant = attribute.hasOwnProperty('3nf_marker') ? attribute['3nf_marker'] === 'yes' : Math.random() > 0.5; // Simulate for demo if field is missing\n\n  if (existingAttr) {\n    // Add the original attribute name if not already present\n    if (!existingAttr.originalAttributes.includes(attribute.label)) {\n      existingAttr.originalAttributes.push(attribute.label);\n    }\n\n    // If any attribute is not 3NF compliant, mark the harmonized attribute as not 3NF\n    if (!is3NFCompliant) {\n      existingAttr.is3NF = false;\n    }\n\n    // Make sure we track that this was moved from its original object\n    existingAttr.moved = true;\n\n    // Keep track of original object if not already set\n    if (!existingAttr.originalObject) {\n      existingAttr.originalObject = originalObjectName;\n    }\n  } else {\n    // Create a new harmonized attribute entry\n    targetObject.harmonizedAttributes.push({\n      name: harmonizedName,\n      count: 1,\n      originalAttributes: [attribute.label],\n      is3NF: is3NFCompliant,\n      moved: true,\n      originalObject: originalObjectName\n    });\n  }\n}","map":{"version":3,"names":["organizeDataForVisualization","data","nodeDataArray","linkDataArray","nodes","links","clusters","filter","node","category","objects","attributes","map","cluster","linkedObjectKeys","link","from","key","to","clusterObjects","obj","includes","linkedAttrKeys","objectAttributes","attr","harmonizedAttributeMap","forEach","harmonizedName","harmonisedAttribute","label","is3NFCompliant","hasOwnProperty","Math","random","name","count","originalAttributes","is3NF","push","harmonizedAttributes","Object","values","sort","a","b","localeCompare","organizeDataForAIRearrangement","newObjectsMap","new_object","newObjectName","objectKey","keys","length","hoverLabel","originalObjects","originalObjectKey","originalObject","find","targetObjectName","addAttributeToNewObject","objectsArray","aiGeneratedCluster","targetObject","attribute","originalObjectName","existingAttr","moved"],"sources":["C:/Users/R40008/Asset Model Server/python/bim-ai-poc/frontend/src/components/TableGraphVisualization/utils/dataOrganizer.js"],"sourcesContent":["/**\r\n * Organizes graph data into a hierarchical structure for visualization\r\n * @param {Object} data - The raw graph data\r\n * @returns {Array} - Array of organized cluster objects\r\n */\r\nexport function organizeDataForVisualization(data) {\r\n  if (!data || !data.nodeDataArray || !data.linkDataArray) {\r\n    return [];\r\n  }\r\n  \r\n  const nodes = data.nodeDataArray;\r\n  const links = data.linkDataArray;\r\n  \r\n  // Extract nodes by category\r\n  const clusters = nodes.filter(node => node.category === \"system\");\r\n  const objects = nodes.filter(node => node.category === \"object\");\r\n  const attributes = nodes.filter(node => node.category === \"attribute\");\r\n  \r\n  // Build the cluster hierarchy\r\n  return clusters.map(cluster => {\r\n    // Find objects linked to this cluster\r\n    const linkedObjectKeys = links\r\n      .filter(link => link.from === cluster.key)\r\n      .map(link => link.to);\r\n      \r\n    const clusterObjects = objects\r\n      .filter(obj => linkedObjectKeys.includes(obj.key))\r\n      .map(obj => {\r\n        // Find attributes linked to this object\r\n        const linkedAttrKeys = links\r\n          .filter(link => link.from === obj.key)\r\n          .map(link => link.to);\r\n          \r\n        const objectAttributes = attributes\r\n          .filter(attr => linkedAttrKeys.includes(attr.key));\r\n        \r\n        // Get harmonized attributes and check 3NF compliance\r\n        const harmonizedAttributeMap = {};\r\n        \r\n        objectAttributes.forEach(attr => {\r\n          // Get the harmonized attribute name\r\n          const harmonizedName = attr.harmonisedAttribute || `Harmonised-${attr.label}`;\r\n          \r\n          // Check if this attribute is 3NF compliant (from the 3nf_marker field)\r\n          const is3NFCompliant = attr.hasOwnProperty('3nf_marker') \r\n            ? attr['3nf_marker'] === 'yes'\r\n            : Math.random() > 0.5; // Simulate for demo if field is missing\r\n          \r\n          if (!harmonizedAttributeMap[harmonizedName]) {\r\n            harmonizedAttributeMap[harmonizedName] = {\r\n              name: harmonizedName,\r\n              count: 1,\r\n              originalAttributes: [attr.label || 'Unknown'],\r\n              is3NF: is3NFCompliant\r\n            };\r\n          } else {\r\n            harmonizedAttributeMap[harmonizedName].count += 1;\r\n            if (!harmonizedAttributeMap[harmonizedName].originalAttributes.includes(attr.label || 'Unknown')) {\r\n              harmonizedAttributeMap[harmonizedName].originalAttributes.push(attr.label || 'Unknown');\r\n            }\r\n            // If any attribute is not 3NF compliant, mark the harmonized attribute as not 3NF\r\n            if (!is3NFCompliant) {\r\n              harmonizedAttributeMap[harmonizedName].is3NF = false;\r\n            }\r\n          }\r\n        });\r\n        \r\n        // Convert map to array and sort alphabetically\r\n        const harmonizedAttributes = Object.values(harmonizedAttributeMap)\r\n          .sort((a, b) => a.name.localeCompare(b.name));\r\n        \r\n        return {\r\n          ...obj,\r\n          attributes: objectAttributes,\r\n          harmonizedAttributes: harmonizedAttributes\r\n        };\r\n      })\r\n      .sort((a, b) => (a.label || '').localeCompare(b.label || ''));\r\n    \r\n    return {\r\n      ...cluster,\r\n      objects: clusterObjects\r\n    };\r\n  }).sort((a, b) => {\r\n    // Sort clusters by name\r\n    return (a.label || '').localeCompare(b.label || '');\r\n  });\r\n}\r\n\r\n/**\r\n * Reorganizes the graph data based on \"new_object\" attribute in CSV\r\n * This simulates AI-powered rearrangement of attributes into better object groupings\r\n * @param {Object} data - The raw graph data\r\n * @returns {Array} - Array of reorganized objects\r\n */\r\nexport function organizeDataForAIRearrangement(data) {\r\n  if (!data || !data.nodeDataArray || !data.linkDataArray) {\r\n    return [];\r\n  }\r\n  \r\n  const nodes = data.nodeDataArray;\r\n  const links = data.linkDataArray;\r\n  const attributes = nodes.filter(node => node.category === \"attribute\");\r\n  \r\n  // Create a map of new objects based on the new_object field in attributes\r\n  const newObjectsMap = {};\r\n  \r\n  // First pass: collect all unique new objects from attributes\r\n  attributes.forEach(attr => {\r\n    if (attr.hasOwnProperty('new_object') && attr.new_object) {\r\n      const newObjectName = attr.new_object;\r\n      \r\n      if (!newObjectsMap[newObjectName]) {\r\n        // Create a new object entry with a unique key\r\n        const objectKey = `new-object-${Object.keys(newObjectsMap).length + 1}`;\r\n        newObjectsMap[newObjectName] = {\r\n          key: objectKey,\r\n          label: newObjectName,\r\n          hoverLabel: `AI-generated object for ${newObjectName} attributes`,\r\n          category: \"object\",\r\n          harmonizedAttributes: []\r\n        };\r\n      }\r\n    }\r\n  });\r\n  \r\n  // Second pass: group attributes by their new objects\r\n  attributes.forEach(attr => {\r\n    // Get the harmonized attribute name\r\n    const harmonizedName = attr.harmonisedAttribute || `Harmonised-${attr.label}`;\r\n    \r\n    // Find original object the attribute belonged to\r\n    const originalObjects = nodes.filter(node => node.category === \"object\");\r\n    const originalObjectKey = links\r\n      .filter(link => link.to === attr.key)\r\n      .map(link => link.from)[0];\r\n    \r\n    const originalObject = originalObjectKey ? \r\n      originalObjects.find(obj => obj.key === originalObjectKey) : null;\r\n    \r\n    // Determine target object (use new_object field if present)\r\n    const targetObjectName = attr.hasOwnProperty('new_object') && attr.new_object \r\n      ? attr.new_object \r\n      : null;\r\n    \r\n    if (targetObjectName && newObjectsMap[targetObjectName]) {\r\n      addAttributeToNewObject(\r\n        newObjectsMap[targetObjectName],\r\n        attr,\r\n        harmonizedName,\r\n        originalObject?.label || \"Unknown\"\r\n      );\r\n    }\r\n  });\r\n  \r\n  // Convert objects map to array and organize into a single \"AI Generated\" cluster\r\n  const objectsArray = Object.values(newObjectsMap);\r\n  \r\n  // Sort objects by name\r\n  objectsArray.sort((a, b) => a.label.localeCompare(b.label));\r\n  \r\n  // Sort harmonized attributes within each object\r\n  objectsArray.forEach(obj => {\r\n    obj.harmonizedAttributes.sort((a, b) => a.name.localeCompare(b.name));\r\n  });\r\n  \r\n  // Create a single cluster containing all new objects\r\n  const aiGeneratedCluster = {\r\n    key: \"ai-generated-cluster\",\r\n    label: \"AI-Generated Structure\",\r\n    category: \"system\",\r\n    hoverLabel: \"Objects reorganized by AI based on attribute relationships and semantics\",\r\n    objects: objectsArray\r\n  };\r\n  \r\n  return [aiGeneratedCluster];\r\n}\r\n\r\n/**\r\n * Helper function to add an attribute to a new object\r\n * @param {Object} targetObject - The object to add the attribute to\r\n * @param {Object} attribute - The attribute to add\r\n * @param {string} harmonizedName - The harmonized name of the attribute\r\n * @param {string} originalObjectName - The name of the original object\r\n */\r\nfunction addAttributeToNewObject(targetObject, attribute, harmonizedName, originalObjectName) {\r\n  // Check if this harmonized attribute is already in the target object\r\n  const existingAttr = targetObject.harmonizedAttributes.find(attr => \r\n    attr.name === harmonizedName\r\n  );\r\n  \r\n  // Check if this attribute is 3NF compliant (from the 3nf_marker field)\r\n  const is3NFCompliant = attribute.hasOwnProperty('3nf_marker') \r\n    ? attribute['3nf_marker'] === 'yes'\r\n    : Math.random() > 0.5; // Simulate for demo if field is missing\r\n  \r\n  if (existingAttr) {\r\n    // Add the original attribute name if not already present\r\n    if (!existingAttr.originalAttributes.includes(attribute.label)) {\r\n      existingAttr.originalAttributes.push(attribute.label);\r\n    }\r\n    \r\n    // If any attribute is not 3NF compliant, mark the harmonized attribute as not 3NF\r\n    if (!is3NFCompliant) {\r\n      existingAttr.is3NF = false;\r\n    }\r\n    \r\n    // Make sure we track that this was moved from its original object\r\n    existingAttr.moved = true;\r\n    \r\n    // Keep track of original object if not already set\r\n    if (!existingAttr.originalObject) {\r\n      existingAttr.originalObject = originalObjectName;\r\n    }\r\n  } else {\r\n    // Create a new harmonized attribute entry\r\n    targetObject.harmonizedAttributes.push({\r\n      name: harmonizedName,\r\n      count: 1,\r\n      originalAttributes: [attribute.label],\r\n      is3NF: is3NFCompliant,\r\n      moved: true,\r\n      originalObject: originalObjectName\r\n    });\r\n  }\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}