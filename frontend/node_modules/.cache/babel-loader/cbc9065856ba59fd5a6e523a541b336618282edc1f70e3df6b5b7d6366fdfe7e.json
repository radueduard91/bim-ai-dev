{"ast":null,"code":"/**\r\n * Organizes graph data into a hierarchical structure for visualization\r\n * @param {Object} data - The raw graph data\r\n * @returns {Array} - Array of organized cluster objects\r\n */\nexport function organizeDataForVisualization(data) {\n  if (!data || !data.nodeDataArray || !data.linkDataArray) {\n    return [];\n  }\n  const {\n    nodeDataArray: nodes,\n    linkDataArray: links\n  } = data;\n\n  // Extract nodes by category\n  const clusters = nodes.filter(node => node.category === \"system\");\n  const objects = nodes.filter(node => node.category === \"object\");\n  const attributes = nodes.filter(node => node.category === \"attribute\");\n\n  // Build the cluster hierarchy\n  return clusters.map(cluster => {\n    // Find objects linked to this cluster\n    const linkedObjectKeys = links.filter(link => link.from === cluster.key).map(link => link.to);\n    const clusterObjects = objects.filter(obj => linkedObjectKeys.includes(obj.key)).map(obj => {\n      // Find attributes linked to this object\n      const linkedAttrKeys = links.filter(link => link.from === obj.key).map(link => link.to);\n      const objectAttributes = attributes.filter(attr => linkedAttrKeys.includes(attr.key));\n\n      // Get harmonized attributes and check 3NF compliance\n      const harmonizedAttributeMap = processHarmonizedAttributes(objectAttributes);\n\n      // Convert map to array and sort alphabetically\n      const harmonizedAttributes = Object.values(harmonizedAttributeMap).sort((a, b) => a.name.localeCompare(b.name));\n      return {\n        ...obj,\n        attributes: objectAttributes,\n        harmonizedAttributes: harmonizedAttributes\n      };\n    }).sort((a, b) => (a.label || '').localeCompare(b.label || ''));\n    return {\n      ...cluster,\n      objects: clusterObjects\n    };\n  }).sort((a, b) => (a.label || '').localeCompare(b.label || ''));\n}\n\n/**\r\n * Process harmonized attributes with 3NF compliance check\r\n * @param {Array} objectAttributes - Attributes to process\r\n * @returns {Object} Mapped harmonized attributes\r\n */\nfunction processHarmonizedAttributes(objectAttributes) {\n  const harmonizedAttributeMap = {};\n  objectAttributes.forEach(attr => {\n    // Get the harmonized attribute name\n    const harmonizedName = attr.harmonisedAttribute || `Harmonised-${attr.label}`;\n\n    // Check if this attribute is 3NF compliant (from the 3nf_marker field)\n    const is3NFCompliant = attr.hasOwnProperty('3nf_marker') ? attr['3nf_marker'] === 'yes' : Math.random() > 0.5; // Simulate for demo if field is missing\n\n    if (!harmonizedAttributeMap[harmonizedName]) {\n      harmonizedAttributeMap[harmonizedName] = {\n        name: harmonizedName,\n        count: 1,\n        originalAttributes: [attr.label || 'Unknown'],\n        is3NF: is3NFCompliant\n      };\n    } else {\n      const existingEntry = harmonizedAttributeMap[harmonizedName];\n      existingEntry.count += 1;\n\n      // Add unique original attributes\n      if (!existingEntry.originalAttributes.includes(attr.label || 'Unknown')) {\n        existingEntry.originalAttributes.push(attr.label || 'Unknown');\n      }\n\n      // Update 3NF status if any attribute is not compliant\n      if (!is3NFCompliant) {\n        existingEntry.is3NF = false;\n      }\n    }\n  });\n  return harmonizedAttributeMap;\n}\n\n/**\r\n * Reorganizes the graph data based on \"new_object\" attribute in CSV\r\n * @param {Object} data - The raw graph data\r\n * @returns {Array} - Array of reorganized objects\r\n */\nexport function organizeDataForAIRearrangement(data) {\n  if (!data || !data.nodeDataArray || !data.linkDataArray) {\n    return [];\n  }\n  const {\n    nodeDataArray: nodes,\n    linkDataArray: links\n  } = data;\n  const attributes = nodes.filter(node => node.category === \"attribute\");\n\n  // Create a map of new objects based on the new_object field in attributes\n  const newObjectsMap = {};\n\n  // Collect unique new objects from attributes\n  // FIX: Account for the column name with trailing space\n  attributes.forEach(attr => {\n    // Try different possible variations of the property name\n    const newObjectValue = attr[\"new_object\"] || attr[\"new_object \"] || null;\n    if (newObjectValue && typeof newObjectValue === 'string' && newObjectValue.trim() !== '') {\n      const newObjectName = newObjectValue.trim();\n      if (!newObjectsMap[newObjectName]) {\n        // Create a new object entry with a unique key\n        const objectKey = `new-object-${Object.keys(newObjectsMap).length + 1}`;\n        newObjectsMap[newObjectName] = {\n          key: objectKey,\n          label: newObjectName,\n          hoverLabel: `AI-organized attributes for ${newObjectName}`,\n          category: \"object\",\n          harmonizedAttributes: []\n        };\n      }\n    }\n  });\n\n  // If no new objects found, create fallback groupings\n  if (Object.keys(newObjectsMap).length === 0) {\n    console.log(\"No new object mappings found in data. Creating default fallback groups.\");\n\n    // Default fallback groups\n    const defaultGroups = [\"Core Entity\", \"Properties\", \"Dimensions\", \"References\"];\n    defaultGroups.forEach((groupName, index) => {\n      const objectKey = `fallback-object-${index}`;\n      newObjectsMap[groupName] = {\n        key: objectKey,\n        label: groupName,\n        hoverLabel: `Default AI grouping for ${groupName.toLowerCase()} attributes`,\n        category: \"object\",\n        harmonizedAttributes: []\n      };\n    });\n\n    // Assign attributes to default groups\n    attributes.forEach((attr, index) => {\n      // Simple distribution algorithm\n      const targetGroup = defaultGroups[index % defaultGroups.length];\n      const harmonizedName = attr.harmonisedAttribute || `Harmonised-${attr.label}`;\n\n      // Find original object\n      const originalObjectKey = links.filter(link => link.to === attr.key).map(link => link.from)[0];\n      const originalObjects = nodes.filter(node => node.category === \"object\");\n      const originalObject = originalObjectKey ? originalObjects.find(obj => obj.key === originalObjectKey) : null;\n      addAttributeToNewObject(newObjectsMap[targetGroup], attr, harmonizedName, (originalObject === null || originalObject === void 0 ? void 0 : originalObject.label) || \"Unknown\");\n    });\n  } else {\n    // Process attributes and add them to the appropriate new object\n    attributes.forEach(attr => {\n      const harmonizedName = attr.harmonisedAttribute || `Harmonised-${attr.label}`;\n\n      // Find original object the attribute belonged to\n      const originalObjectKey = links.filter(link => link.to === attr.key).map(link => link.from)[0];\n      const originalObjects = nodes.filter(node => node.category === \"object\");\n      const originalObject = originalObjectKey ? originalObjects.find(obj => obj.key === originalObjectKey) : null;\n\n      // FIX: Try different possible variations of the property name\n      const newObjectValue = attr[\"new_object\"] || attr[\"new_object \"] || null;\n\n      // Determine target object (use new_object field or fallback)\n      const targetObjectName = newObjectValue && typeof newObjectValue === 'string' && newObjectValue.trim() !== '' ? newObjectValue.trim() : \"Other\";\n\n      // Ensure \"Other\" category exists if needed\n      if (targetObjectName === \"Other\" && !newObjectsMap[\"Other\"]) {\n        const objectKey = `new-object-other`;\n        newObjectsMap[\"Other\"] = {\n          key: objectKey,\n          label: \"Other\",\n          hoverLabel: \"Attributes not assigned to a specific object\",\n          category: \"object\",\n          harmonizedAttributes: []\n        };\n      }\n\n      // Add to appropriate new object\n      const targetObject = newObjectsMap[targetObjectName] || newObjectsMap[\"Other\"];\n      if (targetObject) {\n        addAttributeToNewObject(targetObject, attr, harmonizedName, (originalObject === null || originalObject === void 0 ? void 0 : originalObject.label) || \"Unknown\");\n      }\n    });\n  }\n\n  // Convert objects map to array and filter out empty objects\n  const objectsArray = Object.values(newObjectsMap).filter(obj => obj.harmonizedAttributes.length > 0);\n\n  // Sort objects and their attributes\n  objectsArray.sort((a, b) => a.label.localeCompare(b.label));\n  objectsArray.forEach(obj => {\n    obj.harmonizedAttributes.sort((a, b) => a.name.localeCompare(b.name));\n  });\n\n  // Create a single cluster containing all new objects\n  const aiGeneratedCluster = {\n    key: \"ai-generated-cluster\",\n    label: \"AI-Generated Structure\",\n    category: \"system\",\n    hoverLabel: \"Objects reorganized based on attribute relationships\",\n    objects: objectsArray\n  };\n  return objectsArray.length > 0 ? [aiGeneratedCluster] : [];\n}\n\n/**\r\n * Helper function to add an attribute to a new object\r\n * @param {Object} targetObject - The object to add the attribute to\r\n * @param {Object} attribute - The attribute to add\r\n * @param {string} harmonizedName - The harmonized name of the attribute\r\n * @param {string} originalObjectName - The name of the original object\r\n */\nfunction addAttributeToNewObject(targetObject, attribute, harmonizedName, originalObjectName) {\n  // Check if this harmonized attribute is already in the target object\n  const existingAttr = targetObject.harmonizedAttributes.find(attr => attr.name === harmonizedName);\n\n  // Check if this attribute is 3NF compliant\n  const is3NFCompliant = attribute.hasOwnProperty('3nf_marker') ? attribute['3nf_marker'] === 'yes' : Math.random() > 0.5; // Simulate for demo if field is missing\n\n  if (existingAttr) {\n    // Add the original attribute name if not already present\n    if (!existingAttr.originalAttributes.includes(attribute.label)) {\n      existingAttr.originalAttributes.push(attribute.label);\n    }\n\n    // If any attribute is not 3NF compliant, mark the harmonized attribute as not 3NF\n    if (!is3NFCompliant) {\n      existingAttr.is3NF = false;\n    }\n\n    // Make sure we track that this was moved from its original object\n    existingAttr.moved = true;\n\n    // Keep track of original object if not already set\n    if (!existingAttr.originalObject) {\n      existingAttr.originalObject = originalObjectName;\n    }\n  } else {\n    // Create a new harmonized attribute entry\n    targetObject.harmonizedAttributes.push({\n      name: harmonizedName,\n      count: 1,\n      originalAttributes: [attribute.label],\n      is3NF: is3NFCompliant,\n      moved: true,\n      originalObject: originalObjectName\n    });\n  }\n}","map":{"version":3,"names":["organizeDataForVisualization","data","nodeDataArray","linkDataArray","nodes","links","clusters","filter","node","category","objects","attributes","map","cluster","linkedObjectKeys","link","from","key","to","clusterObjects","obj","includes","linkedAttrKeys","objectAttributes","attr","harmonizedAttributeMap","processHarmonizedAttributes","harmonizedAttributes","Object","values","sort","a","b","name","localeCompare","label","forEach","harmonizedName","harmonisedAttribute","is3NFCompliant","hasOwnProperty","Math","random","count","originalAttributes","is3NF","existingEntry","push","organizeDataForAIRearrangement","newObjectsMap","newObjectValue","trim","newObjectName","objectKey","keys","length","hoverLabel","console","log","defaultGroups","groupName","index","toLowerCase","targetGroup","originalObjectKey","originalObjects","originalObject","find","addAttributeToNewObject","targetObjectName","targetObject","objectsArray","aiGeneratedCluster","attribute","originalObjectName","existingAttr","moved"],"sources":["C:/Users/R40008/Asset Model Server/python/bim-ai-poc/frontend/src/components/TableGraphVisualization/utils/dataOrganizer.js"],"sourcesContent":["/**\r\n * Organizes graph data into a hierarchical structure for visualization\r\n * @param {Object} data - The raw graph data\r\n * @returns {Array} - Array of organized cluster objects\r\n */\r\nexport function organizeDataForVisualization(data) {\r\n  if (!data || !data.nodeDataArray || !data.linkDataArray) {\r\n    return [];\r\n  }\r\n  \r\n  const { nodeDataArray: nodes, linkDataArray: links } = data;\r\n  \r\n  // Extract nodes by category\r\n  const clusters = nodes.filter(node => node.category === \"system\");\r\n  const objects = nodes.filter(node => node.category === \"object\");\r\n  const attributes = nodes.filter(node => node.category === \"attribute\");\r\n  \r\n  // Build the cluster hierarchy\r\n  return clusters\r\n    .map(cluster => {\r\n      // Find objects linked to this cluster\r\n      const linkedObjectKeys = links\r\n        .filter(link => link.from === cluster.key)\r\n        .map(link => link.to);\r\n        \r\n      const clusterObjects = objects\r\n        .filter(obj => linkedObjectKeys.includes(obj.key))\r\n        .map(obj => {\r\n          // Find attributes linked to this object\r\n          const linkedAttrKeys = links\r\n            .filter(link => link.from === obj.key)\r\n            .map(link => link.to);\r\n            \r\n          const objectAttributes = attributes\r\n            .filter(attr => linkedAttrKeys.includes(attr.key));\r\n          \r\n          // Get harmonized attributes and check 3NF compliance\r\n          const harmonizedAttributeMap = processHarmonizedAttributes(objectAttributes);\r\n          \r\n          // Convert map to array and sort alphabetically\r\n          const harmonizedAttributes = Object.values(harmonizedAttributeMap)\r\n            .sort((a, b) => a.name.localeCompare(b.name));\r\n          \r\n          return {\r\n            ...obj,\r\n            attributes: objectAttributes,\r\n            harmonizedAttributes: harmonizedAttributes\r\n          };\r\n        })\r\n        .sort((a, b) => (a.label || '').localeCompare(b.label || ''));\r\n      \r\n      return {\r\n        ...cluster,\r\n        objects: clusterObjects\r\n      };\r\n    })\r\n    .sort((a, b) => (a.label || '').localeCompare(b.label || ''));\r\n}\r\n\r\n/**\r\n * Process harmonized attributes with 3NF compliance check\r\n * @param {Array} objectAttributes - Attributes to process\r\n * @returns {Object} Mapped harmonized attributes\r\n */\r\nfunction processHarmonizedAttributes(objectAttributes) {\r\n  const harmonizedAttributeMap = {};\r\n  \r\n  objectAttributes.forEach(attr => {\r\n    // Get the harmonized attribute name\r\n    const harmonizedName = attr.harmonisedAttribute || `Harmonised-${attr.label}`;\r\n    \r\n    // Check if this attribute is 3NF compliant (from the 3nf_marker field)\r\n    const is3NFCompliant = attr.hasOwnProperty('3nf_marker') \r\n      ? attr['3nf_marker'] === 'yes'\r\n      : Math.random() > 0.5; // Simulate for demo if field is missing\r\n    \r\n    if (!harmonizedAttributeMap[harmonizedName]) {\r\n      harmonizedAttributeMap[harmonizedName] = {\r\n        name: harmonizedName,\r\n        count: 1,\r\n        originalAttributes: [attr.label || 'Unknown'],\r\n        is3NF: is3NFCompliant\r\n      };\r\n    } else {\r\n      const existingEntry = harmonizedAttributeMap[harmonizedName];\r\n      \r\n      existingEntry.count += 1;\r\n      \r\n      // Add unique original attributes\r\n      if (!existingEntry.originalAttributes.includes(attr.label || 'Unknown')) {\r\n        existingEntry.originalAttributes.push(attr.label || 'Unknown');\r\n      }\r\n      \r\n      // Update 3NF status if any attribute is not compliant\r\n      if (!is3NFCompliant) {\r\n        existingEntry.is3NF = false;\r\n      }\r\n    }\r\n  });\r\n  \r\n  return harmonizedAttributeMap;\r\n}\r\n\r\n/**\r\n * Reorganizes the graph data based on \"new_object\" attribute in CSV\r\n * @param {Object} data - The raw graph data\r\n * @returns {Array} - Array of reorganized objects\r\n */\r\nexport function organizeDataForAIRearrangement(data) {\r\n  if (!data || !data.nodeDataArray || !data.linkDataArray) {\r\n    return [];\r\n  }\r\n  \r\n  const { nodeDataArray: nodes, linkDataArray: links } = data;\r\n  const attributes = nodes.filter(node => node.category === \"attribute\");\r\n  \r\n  // Create a map of new objects based on the new_object field in attributes\r\n  const newObjectsMap = {};\r\n  \r\n  // Collect unique new objects from attributes\r\n  // FIX: Account for the column name with trailing space\r\n  attributes.forEach(attr => {\r\n    // Try different possible variations of the property name\r\n    const newObjectValue = attr[\"new_object\"] || attr[\"new_object \"] || null;\r\n    \r\n    if (newObjectValue && typeof newObjectValue === 'string' && newObjectValue.trim() !== '') {\r\n      const newObjectName = newObjectValue.trim();\r\n      \r\n      if (!newObjectsMap[newObjectName]) {\r\n        // Create a new object entry with a unique key\r\n        const objectKey = `new-object-${Object.keys(newObjectsMap).length + 1}`;\r\n        newObjectsMap[newObjectName] = {\r\n          key: objectKey,\r\n          label: newObjectName,\r\n          hoverLabel: `AI-organized attributes for ${newObjectName}`,\r\n          category: \"object\",\r\n          harmonizedAttributes: []\r\n        };\r\n      }\r\n    }\r\n  });\r\n\r\n  // If no new objects found, create fallback groupings\r\n  if (Object.keys(newObjectsMap).length === 0) {\r\n    console.log(\"No new object mappings found in data. Creating default fallback groups.\");\r\n    \r\n    // Default fallback groups\r\n    const defaultGroups = [\"Core Entity\", \"Properties\", \"Dimensions\", \"References\"];\r\n    defaultGroups.forEach((groupName, index) => {\r\n      const objectKey = `fallback-object-${index}`;\r\n      newObjectsMap[groupName] = {\r\n        key: objectKey,\r\n        label: groupName,\r\n        hoverLabel: `Default AI grouping for ${groupName.toLowerCase()} attributes`,\r\n        category: \"object\",\r\n        harmonizedAttributes: []\r\n      };\r\n    });\r\n    \r\n    // Assign attributes to default groups\r\n    attributes.forEach((attr, index) => {\r\n      // Simple distribution algorithm\r\n      const targetGroup = defaultGroups[index % defaultGroups.length];\r\n      const harmonizedName = attr.harmonisedAttribute || `Harmonised-${attr.label}`;\r\n      \r\n      // Find original object\r\n      const originalObjectKey = links\r\n        .filter(link => link.to === attr.key)\r\n        .map(link => link.from)[0];\r\n      \r\n      const originalObjects = nodes.filter(node => node.category === \"object\");\r\n      const originalObject = originalObjectKey ? \r\n        originalObjects.find(obj => obj.key === originalObjectKey) : null;\r\n      \r\n      addAttributeToNewObject(\r\n        newObjectsMap[targetGroup],\r\n        attr,\r\n        harmonizedName,\r\n        originalObject?.label || \"Unknown\"\r\n      );\r\n    });\r\n  } else {\r\n    // Process attributes and add them to the appropriate new object\r\n    attributes.forEach(attr => {\r\n      const harmonizedName = attr.harmonisedAttribute || `Harmonised-${attr.label}`;\r\n      \r\n      // Find original object the attribute belonged to\r\n      const originalObjectKey = links\r\n        .filter(link => link.to === attr.key)\r\n        .map(link => link.from)[0];\r\n      \r\n      const originalObjects = nodes.filter(node => node.category === \"object\");\r\n      const originalObject = originalObjectKey ? \r\n        originalObjects.find(obj => obj.key === originalObjectKey) : null;\r\n      \r\n      // FIX: Try different possible variations of the property name\r\n      const newObjectValue = attr[\"new_object\"] || attr[\"new_object \"] || null;\r\n      \r\n      // Determine target object (use new_object field or fallback)\r\n      const targetObjectName = (newObjectValue && typeof newObjectValue === 'string' && newObjectValue.trim() !== '')\r\n        ? newObjectValue.trim()\r\n        : \"Other\";\r\n      \r\n      // Ensure \"Other\" category exists if needed\r\n      if (targetObjectName === \"Other\" && !newObjectsMap[\"Other\"]) {\r\n        const objectKey = `new-object-other`;\r\n        newObjectsMap[\"Other\"] = {\r\n          key: objectKey,\r\n          label: \"Other\",\r\n          hoverLabel: \"Attributes not assigned to a specific object\",\r\n          category: \"object\",\r\n          harmonizedAttributes: []\r\n        };\r\n      }\r\n      \r\n      // Add to appropriate new object\r\n      const targetObject = newObjectsMap[targetObjectName] || newObjectsMap[\"Other\"];\r\n      \r\n      if (targetObject) {\r\n        addAttributeToNewObject(\r\n          targetObject,\r\n          attr,\r\n          harmonizedName,\r\n          originalObject?.label || \"Unknown\"\r\n        );\r\n      }\r\n    });\r\n  }\r\n  \r\n  // Convert objects map to array and filter out empty objects\r\n  const objectsArray = Object.values(newObjectsMap)\r\n    .filter(obj => obj.harmonizedAttributes.length > 0);\r\n  \r\n  // Sort objects and their attributes\r\n  objectsArray.sort((a, b) => a.label.localeCompare(b.label));\r\n  objectsArray.forEach(obj => {\r\n    obj.harmonizedAttributes.sort((a, b) => a.name.localeCompare(b.name));\r\n  });\r\n  \r\n  // Create a single cluster containing all new objects\r\n  const aiGeneratedCluster = {\r\n    key: \"ai-generated-cluster\",\r\n    label: \"AI-Generated Structure\",\r\n    category: \"system\",\r\n    hoverLabel: \"Objects reorganized based on attribute relationships\",\r\n    objects: objectsArray\r\n  };\r\n  \r\n  return objectsArray.length > 0 ? [aiGeneratedCluster] : [];\r\n}\r\n\r\n/**\r\n * Helper function to add an attribute to a new object\r\n * @param {Object} targetObject - The object to add the attribute to\r\n * @param {Object} attribute - The attribute to add\r\n * @param {string} harmonizedName - The harmonized name of the attribute\r\n * @param {string} originalObjectName - The name of the original object\r\n */\r\nfunction addAttributeToNewObject(targetObject, attribute, harmonizedName, originalObjectName) {\r\n  // Check if this harmonized attribute is already in the target object\r\n  const existingAttr = targetObject.harmonizedAttributes.find(attr => \r\n    attr.name === harmonizedName\r\n  );\r\n  \r\n  // Check if this attribute is 3NF compliant\r\n  const is3NFCompliant = attribute.hasOwnProperty('3nf_marker') \r\n    ? attribute['3nf_marker'] === 'yes'\r\n    : Math.random() > 0.5; // Simulate for demo if field is missing\r\n  \r\n  if (existingAttr) {\r\n    // Add the original attribute name if not already present\r\n    if (!existingAttr.originalAttributes.includes(attribute.label)) {\r\n      existingAttr.originalAttributes.push(attribute.label);\r\n    }\r\n    \r\n    // If any attribute is not 3NF compliant, mark the harmonized attribute as not 3NF\r\n    if (!is3NFCompliant) {\r\n      existingAttr.is3NF = false;\r\n    }\r\n    \r\n    // Make sure we track that this was moved from its original object\r\n    existingAttr.moved = true;\r\n    \r\n    // Keep track of original object if not already set\r\n    if (!existingAttr.originalObject) {\r\n      existingAttr.originalObject = originalObjectName;\r\n    }\r\n  } else {\r\n    // Create a new harmonized attribute entry\r\n    targetObject.harmonizedAttributes.push({\r\n      name: harmonizedName,\r\n      count: 1,\r\n      originalAttributes: [attribute.label],\r\n      is3NF: is3NFCompliant,\r\n      moved: true,\r\n      originalObject: originalObjectName\r\n    });\r\n  }\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}