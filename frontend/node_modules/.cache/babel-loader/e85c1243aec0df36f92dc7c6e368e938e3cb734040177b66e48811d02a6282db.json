{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect, useMemo } from 'react';\nimport { sortRows, processRowSpans } from '../RowProcessing';\nimport { calculateCounts } from '../CountCalculators';\nimport { filterAndSortRows } from '../FilterSortUtils';\n\n/**\r\n * Custom hook to handle row processing, sorting, filtering, and calculations\r\n */\nexport const useRowProcessing = (graphData, searchTerm, filterCategory, sortConfig, currentPage, ROWS_PER_PAGE) => {\n  _s();\n  // State for processed data\n  const [sortedRows, setSortedRows] = useState([]);\n  const [rowSpans, setRowSpans] = useState({});\n  const [clusterCounts, setClusterCounts] = useState({});\n  const [objectCounts, setObjectCounts] = useState({});\n\n  // Process graph data when it changes\n  useEffect(() => {\n    if (graphData && graphData.nodeDataArray.length > 0) {\n      const clusters = graphData.nodeDataArray.filter(node => node.category === \"system\");\n      const objects = graphData.nodeDataArray.filter(node => node.category === \"object\");\n      const attributes = graphData.nodeDataArray.filter(node => node.category === \"attribute\");\n\n      // Create rows with relationships\n      const rows = attributes.map(attr => {\n        const parentObject = objects.find(obj => graphData.linkDataArray.some(link => link.from === obj.key && link.to === attr.key));\n        const parentCluster = parentObject ? clusters.find(sys => graphData.linkDataArray.some(link => link.from === sys.key && link.to === parentObject.key)) : null;\n        return {\n          attr,\n          parentObject,\n          parentCluster\n        };\n      });\n\n      // Sort rows\n      const sorted = sortRows(rows);\n      setSortedRows(sorted);\n\n      // Process row spans\n      const spans = processRowSpans(sorted);\n      setRowSpans(spans);\n\n      // Calculate counts\n      const {\n        clusterCounts,\n        objectCounts\n      } = calculateCounts(graphData);\n      setClusterCounts(clusterCounts);\n      setObjectCounts(objectCounts);\n    }\n  }, [graphData]);\n\n  // Filter and sort the rows\n  const filteredAndSortedRows = useMemo(() => filterAndSortRows(sortedRows, searchTerm, filterCategory, sortConfig), [sortedRows, searchTerm, filterCategory, sortConfig]);\n\n  // Paginate the rows\n  const paginatedRows = useMemo(() => {\n    const startIndex = (currentPage - 1) * ROWS_PER_PAGE;\n    return filteredAndSortedRows.slice(startIndex, startIndex + ROWS_PER_PAGE);\n  }, [filteredAndSortedRows, currentPage, ROWS_PER_PAGE]);\n\n  // Calculate total pages\n  const totalPages = Math.ceil(filteredAndSortedRows.length / ROWS_PER_PAGE);\n  return {\n    sortedRows,\n    rowSpans,\n    clusterCounts,\n    objectCounts,\n    filteredAndSortedRows,\n    paginatedRows,\n    totalPages\n  };\n};\n_s(useRowProcessing, \"dTZ/6fzR0rSyrp8e0qPEUQDcDoQ=\");","map":{"version":3,"names":["useState","useEffect","useMemo","sortRows","processRowSpans","calculateCounts","filterAndSortRows","useRowProcessing","graphData","searchTerm","filterCategory","sortConfig","currentPage","ROWS_PER_PAGE","_s","sortedRows","setSortedRows","rowSpans","setRowSpans","clusterCounts","setClusterCounts","objectCounts","setObjectCounts","nodeDataArray","length","clusters","filter","node","category","objects","attributes","rows","map","attr","parentObject","find","obj","linkDataArray","some","link","from","key","to","parentCluster","sys","sorted","spans","filteredAndSortedRows","paginatedRows","startIndex","slice","totalPages","Math","ceil"],"sources":["C:/Users/R40008/Asset Model Server/python/bim-ai-dev/frontend/src/components/TableVisualization/hooks/useRowProcessing.js"],"sourcesContent":["import { useState, useEffect, useMemo } from 'react';\r\nimport { sortRows, processRowSpans } from '../RowProcessing';\r\nimport { calculateCounts } from '../CountCalculators';\r\nimport { filterAndSortRows } from '../FilterSortUtils';\r\n\r\n/**\r\n * Custom hook to handle row processing, sorting, filtering, and calculations\r\n */\r\nexport const useRowProcessing = (\r\n    graphData, \r\n    searchTerm, \r\n    filterCategory, \r\n    sortConfig, \r\n    currentPage,\r\n    ROWS_PER_PAGE\r\n) => {\r\n    // State for processed data\r\n    const [sortedRows, setSortedRows] = useState([]);\r\n    const [rowSpans, setRowSpans] = useState({});\r\n    const [clusterCounts, setClusterCounts] = useState({});\r\n    const [objectCounts, setObjectCounts] = useState({});\r\n\r\n    // Process graph data when it changes\r\n    useEffect(() => {\r\n        if (graphData && graphData.nodeDataArray.length > 0) {\r\n            const clusters = graphData.nodeDataArray.filter((node) => node.category === \"system\");\r\n            const objects = graphData.nodeDataArray.filter((node) => node.category === \"object\");\r\n            const attributes = graphData.nodeDataArray.filter((node) => node.category === \"attribute\");\r\n\r\n            // Create rows with relationships\r\n            const rows = attributes.map((attr) => {\r\n                const parentObject = objects.find((obj) =>\r\n                    graphData.linkDataArray.some((link) => link.from === obj.key && link.to === attr.key)\r\n                );\r\n\r\n                const parentCluster = parentObject\r\n                    ? clusters.find((sys) =>\r\n                        graphData.linkDataArray.some((link) => link.from === sys.key && link.to === parentObject.key)\r\n                    )\r\n                    : null;\r\n\r\n                return { attr, parentObject, parentCluster };\r\n            });\r\n\r\n            // Sort rows\r\n            const sorted = sortRows(rows);\r\n            setSortedRows(sorted);\r\n\r\n            // Process row spans\r\n            const spans = processRowSpans(sorted);\r\n            setRowSpans(spans);\r\n\r\n            // Calculate counts\r\n            const { clusterCounts, objectCounts } = calculateCounts(graphData);\r\n            setClusterCounts(clusterCounts);\r\n            setObjectCounts(objectCounts);\r\n        }\r\n    }, [graphData]);\r\n\r\n    // Filter and sort the rows\r\n    const filteredAndSortedRows = useMemo(() => \r\n        filterAndSortRows(sortedRows, searchTerm, filterCategory, sortConfig), \r\n        [sortedRows, searchTerm, filterCategory, sortConfig]\r\n    );\r\n\r\n    // Paginate the rows\r\n    const paginatedRows = useMemo(() => {\r\n        const startIndex = (currentPage - 1) * ROWS_PER_PAGE;\r\n        return filteredAndSortedRows.slice(startIndex, startIndex + ROWS_PER_PAGE);\r\n    }, [filteredAndSortedRows, currentPage, ROWS_PER_PAGE]);\r\n\r\n    // Calculate total pages\r\n    const totalPages = Math.ceil(filteredAndSortedRows.length / ROWS_PER_PAGE);\r\n\r\n    return {\r\n        sortedRows,\r\n        rowSpans,\r\n        clusterCounts,\r\n        objectCounts,\r\n        filteredAndSortedRows,\r\n        paginatedRows,\r\n        totalPages\r\n    };\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}