{"ast":null,"code":"/**\r\n * Organizes graph data into a hierarchical structure for visualization\r\n * @param {Object} data - The raw graph data\r\n * @returns {Array} - Array of organized cluster objects\r\n */\nexport function organizeDataForVisualization(data) {\n  // ... (existing code remains the same)\n}\n\n/**\r\n * Process harmonized attributes with 3NF compliance check\r\n * @param {Array} objectAttributes - Attributes to process\r\n * @returns {Object} Mapped harmonized attributes\r\n */\nfunction processHarmonizedAttributes(objectAttributes) {\n  // ... (existing code remains the same)\n}\n\n/**\r\n * Reorganizes the graph data based on \"new_object\" attribute in CSV\r\n * @param {Object} data - The raw graph data\r\n * @returns {Array} - Array of reorganized objects\r\n */\nexport function organizeDataForAIRearrangement(data) {\n  if (!data || !data.nodeDataArray || !data.linkDataArray) {\n    return [];\n  }\n  const {\n    nodeDataArray: nodes,\n    linkDataArray: links\n  } = data;\n  const attributes = nodes.filter(node => node.category === \"attribute\");\n\n  // Create a map of new objects based on the new_object field in attributes\n  const newObjectsMap = {};\n\n  // Collect unique new objects from attributes\n  attributes.forEach(attr => {\n    if (attr.hasOwnProperty('new_object') && attr.new_object) {\n      const newObjectName = attr.new_object;\n      if (!newObjectsMap[newObjectName]) {\n        // Create a new object entry with a unique key\n        const objectKey = `new-object-${Object.keys(newObjectsMap).length + 1}`;\n        newObjectsMap[newObjectName] = {\n          key: objectKey,\n          label: newObjectName,\n          hoverLabel: `AI-organized attributes for ${newObjectName}`,\n          category: \"object\",\n          harmonizedAttributes: []\n        };\n      }\n    }\n  });\n\n  // Process attributes and add them to the appropriate new object\n  attributes.forEach(attr => {\n    const harmonizedName = attr.harmonisedAttribute || `Harmonised-${attr.label}`;\n\n    // Find original object the attribute belonged to\n    const originalObjectKey = links.filter(link => link.to === attr.key).map(link => link.from)[0];\n    const originalObjects = nodes.filter(node => node.category === \"object\");\n    const originalObject = originalObjectKey ? originalObjects.find(obj => obj.key === originalObjectKey) : null;\n\n    // Determine target object (use new_object field if present)\n    const targetObjectName = attr.hasOwnProperty('new_object') && attr.new_object ? attr.new_object : null;\n    if (targetObjectName) {\n      // Create the target object if it doesn't exist\n      if (!newObjectsMap[targetObjectName]) {\n        const objectKey = `new-object-${Object.keys(newObjectsMap).length + 1}`;\n        newObjectsMap[targetObjectName] = {\n          key: objectKey,\n          label: targetObjectName,\n          hoverLabel: `AI-organized attributes for ${targetObjectName}`,\n          category: \"object\",\n          harmonizedAttributes: []\n        };\n      }\n\n      // Add to the appropriate new object\n      const targetObject = newObjectsMap[targetObjectName];\n      addAttributeToNewObject(targetObject, attr, harmonizedName, (originalObject === null || originalObject === void 0 ? void 0 : originalObject.label) || \"Unknown\");\n    }\n  });\n\n  // Convert objects map to array and filter out empty objects\n  const objectsArray = Object.values(newObjectsMap).filter(obj => obj.harmonizedAttributes.length > 0);\n\n  // Sort objects and their attributes\n  objectsArray.sort((a, b) => a.label.localeCompare(b.label));\n  objectsArray.forEach(obj => {\n    obj.harmonizedAttributes.sort((a, b) => a.name.localeCompare(b.name));\n  });\n\n  // Create a single cluster containing all new objects\n  const aiGeneratedCluster = {\n    key: \"ai-generated-cluster\",\n    label: \"AI-Generated Structure\",\n    category: \"system\",\n    hoverLabel: \"Objects reorganized based on attribute relationships\",\n    objects: objectsArray\n  };\n  return objectsArray.length > 0 ? [aiGeneratedCluster] : [];\n}\n\n/**\r\n * Helper function to add an attribute to a new object\r\n * @param {Object} targetObject - The object to add the attribute to\r\n * @param {Object} attribute - The attribute to add\r\n * @param {string} harmonizedName - The harmonized name of the attribute\r\n * @param {string} originalObjectName - The name of the original object\r\n */\nfunction addAttributeToNewObject(targetObject, attribute, harmonizedName, originalObjectName) {\n  // ... (existing code remains the same)\n}","map":{"version":3,"names":["organizeDataForVisualization","data","processHarmonizedAttributes","objectAttributes","organizeDataForAIRearrangement","nodeDataArray","linkDataArray","nodes","links","attributes","filter","node","category","newObjectsMap","forEach","attr","hasOwnProperty","new_object","newObjectName","objectKey","Object","keys","length","key","label","hoverLabel","harmonizedAttributes","harmonizedName","harmonisedAttribute","originalObjectKey","link","to","map","from","originalObjects","originalObject","find","obj","targetObjectName","targetObject","addAttributeToNewObject","objectsArray","values","sort","a","b","localeCompare","name","aiGeneratedCluster","objects","attribute","originalObjectName"],"sources":["C:/Users/R40008/Asset Model Server/python/bim-ai-poc/frontend/src/components/TableGraphVisualization/utils/dataOrganizer.js"],"sourcesContent":["/**\r\n * Organizes graph data into a hierarchical structure for visualization\r\n * @param {Object} data - The raw graph data\r\n * @returns {Array} - Array of organized cluster objects\r\n */\r\nexport function organizeDataForVisualization(data) {\r\n  // ... (existing code remains the same)\r\n}\r\n\r\n/**\r\n * Process harmonized attributes with 3NF compliance check\r\n * @param {Array} objectAttributes - Attributes to process\r\n * @returns {Object} Mapped harmonized attributes\r\n */\r\nfunction processHarmonizedAttributes(objectAttributes) {\r\n  // ... (existing code remains the same)\r\n}\r\n\r\n/**\r\n * Reorganizes the graph data based on \"new_object\" attribute in CSV\r\n * @param {Object} data - The raw graph data\r\n * @returns {Array} - Array of reorganized objects\r\n */\r\nexport function organizeDataForAIRearrangement(data) {\r\n  if (!data || !data.nodeDataArray || !data.linkDataArray) {\r\n    return [];\r\n  }\r\n  \r\n  const { nodeDataArray: nodes, linkDataArray: links } = data;\r\n  const attributes = nodes.filter(node => node.category === \"attribute\");\r\n  \r\n  // Create a map of new objects based on the new_object field in attributes\r\n  const newObjectsMap = {};\r\n  \r\n  // Collect unique new objects from attributes\r\n  attributes.forEach(attr => {\r\n    if (attr.hasOwnProperty('new_object') && attr.new_object) {\r\n      const newObjectName = attr.new_object;\r\n      \r\n      if (!newObjectsMap[newObjectName]) {\r\n        // Create a new object entry with a unique key\r\n        const objectKey = `new-object-${Object.keys(newObjectsMap).length + 1}`;\r\n        newObjectsMap[newObjectName] = {\r\n          key: objectKey,\r\n          label: newObjectName,\r\n          hoverLabel: `AI-organized attributes for ${newObjectName}`,\r\n          category: \"object\",\r\n          harmonizedAttributes: []\r\n        };\r\n      }\r\n    }\r\n  });\r\n\r\n  // Process attributes and add them to the appropriate new object\r\n  attributes.forEach(attr => {\r\n    const harmonizedName = attr.harmonisedAttribute || `Harmonised-${attr.label}`;\r\n    \r\n    // Find original object the attribute belonged to\r\n    const originalObjectKey = links\r\n      .filter(link => link.to === attr.key)\r\n      .map(link => link.from)[0];\r\n    \r\n    const originalObjects = nodes.filter(node => node.category === \"object\");\r\n    const originalObject = originalObjectKey ? \r\n      originalObjects.find(obj => obj.key === originalObjectKey) : null;\r\n    \r\n    // Determine target object (use new_object field if present)\r\n    const targetObjectName = attr.hasOwnProperty('new_object') && attr.new_object \r\n      ? attr.new_object \r\n      : null;\r\n    \r\n    if (targetObjectName) {\r\n      // Create the target object if it doesn't exist\r\n      if (!newObjectsMap[targetObjectName]) {\r\n        const objectKey = `new-object-${Object.keys(newObjectsMap).length + 1}`;\r\n        newObjectsMap[targetObjectName] = {\r\n          key: objectKey,\r\n          label: targetObjectName,\r\n          hoverLabel: `AI-organized attributes for ${targetObjectName}`,\r\n          category: \"object\",\r\n          harmonizedAttributes: []\r\n        };\r\n      }\r\n      \r\n      // Add to the appropriate new object\r\n      const targetObject = newObjectsMap[targetObjectName];\r\n      addAttributeToNewObject(\r\n        targetObject,\r\n        attr,\r\n        harmonizedName,\r\n        originalObject?.label || \"Unknown\"\r\n      );\r\n    }\r\n  });\r\n  \r\n  // Convert objects map to array and filter out empty objects\r\n  const objectsArray = Object.values(newObjectsMap)\r\n    .filter(obj => obj.harmonizedAttributes.length > 0);\r\n  \r\n  // Sort objects and their attributes\r\n  objectsArray.sort((a, b) => a.label.localeCompare(b.label));\r\n  objectsArray.forEach(obj => {\r\n    obj.harmonizedAttributes.sort((a, b) => a.name.localeCompare(b.name));\r\n  });\r\n  \r\n  // Create a single cluster containing all new objects\r\n  const aiGeneratedCluster = {\r\n    key: \"ai-generated-cluster\",\r\n    label: \"AI-Generated Structure\",\r\n    category: \"system\",\r\n    hoverLabel: \"Objects reorganized based on attribute relationships\",\r\n    objects: objectsArray\r\n  };\r\n  \r\n  return objectsArray.length > 0 ? [aiGeneratedCluster] : [];\r\n}\r\n\r\n/**\r\n * Helper function to add an attribute to a new object\r\n * @param {Object} targetObject - The object to add the attribute to\r\n * @param {Object} attribute - The attribute to add\r\n * @param {string} harmonizedName - The harmonized name of the attribute\r\n * @param {string} originalObjectName - The name of the original object\r\n */\r\nfunction addAttributeToNewObject(targetObject, attribute, harmonizedName, originalObjectName) {\r\n  // ... (existing code remains the same)\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}