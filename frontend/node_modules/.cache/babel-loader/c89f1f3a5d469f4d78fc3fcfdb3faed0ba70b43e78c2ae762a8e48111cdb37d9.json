{"ast":null,"code":"/**\r\n * Reorganizes the graph data based on \"new_object\" attribute in CSV\r\n * @param {Object} data - The raw graph data\r\n * @returns {Array} - Array of reorganized objects\r\n */\nexport function organizeDataForAIRearrangement(data) {\n  if (!data || !data.nodeDataArray || !data.linkDataArray) {\n    console.log(\"No data available for AI rearrangement\");\n    return [];\n  }\n  const {\n    nodeDataArray: nodes,\n    linkDataArray: links\n  } = data;\n  const attributes = nodes.filter(node => node.category === \"attribute\");\n  console.log(`Total number of attributes: ${attributes.length}`);\n\n  // For debugging - check what properties are available in the first few attributes\n  if (attributes.length > 0) {\n    const sampleAttr = attributes[0];\n    const keys = Object.keys(sampleAttr);\n    console.log(\"First attribute properties:\", keys);\n    console.log(\"First attribute sample:\", sampleAttr);\n\n    // Show the actual properties and values\n    console.log(\"Property details:\");\n    keys.forEach(key => {\n      console.log(`  \"${key}\": \"${sampleAttr[key]}\"`);\n    });\n  } else {\n    console.log(\"No attributes found in data\");\n  }\n\n  // Create a map of new objects based on the new_object field in attributes\n  const newObjectsMap = {};\n\n  // Check for various forms of the new_object column\n  const newObjectKeys = [\"new_object\", \"new_object \", \"newobject\", \"NewObject\"];\n  let foundNewObjectKey = null;\n\n  // Find which key is present in the attributes\n  if (attributes.length > 0) {\n    const sampleAttr = attributes[0];\n    for (const key of newObjectKeys) {\n      if (sampleAttr.hasOwnProperty(key)) {\n        foundNewObjectKey = key;\n        console.log(`Found new_object key as: \"${key}\" with value: \"${sampleAttr[key]}\"`);\n        break;\n      }\n    }\n    if (!foundNewObjectKey) {\n      console.log(\"Could not find any new_object key. Available keys:\", Object.keys(sampleAttr));\n    }\n  }\n\n  // Attempt to find ANY property that might have values like \"Transformator\"\n  attributes.forEach((attr, index) => {\n    if (index < 10) {\n      // Check just the first 10 attributes\n      console.log(`Examining attribute ${index}: ${attr.label}`);\n      for (const prop in attr) {\n        const value = attr[prop];\n        if (typeof value === 'string') {\n          console.log(`  Property \"${prop}\" has string value: \"${value}\"`);\n        }\n      }\n    }\n  });\n\n  // Count attributes with new_object values\n  let attributesWithNewObject = 0;\n  const newObjectValues = new Set();\n  attributes.forEach((attr, index) => {\n    let newObjectValue = null;\n\n    // Try the found key first\n    if (foundNewObjectKey && attr[foundNewObjectKey]) {\n      newObjectValue = attr[foundNewObjectKey];\n    } else {\n      // Otherwise try all possible variations\n      for (const key of newObjectKeys) {\n        if (attr.hasOwnProperty(key) && attr[key] && attr[key].trim() !== '') {\n          newObjectValue = attr[key];\n          if (!foundNewObjectKey) foundNewObjectKey = key;\n          break;\n        }\n      }\n    }\n    if (newObjectValue && typeof newObjectValue === 'string' && newObjectValue.trim() !== '') {\n      // Sample the first few values for debugging\n      if (index < 5) {\n        console.log(`Attribute ${index} (${attr.label}) has \"${foundNewObjectKey}\" value: \"${newObjectValue}\"`);\n      }\n      attributesWithNewObject++;\n      newObjectValues.add(newObjectValue.trim());\n      const newObjectName = newObjectValue.trim();\n      if (!newObjectsMap[newObjectName]) {\n        const objectKey = `new-object-${Object.keys(newObjectsMap).length + 1}`;\n        newObjectsMap[newObjectName] = {\n          key: objectKey,\n          label: newObjectName,\n          hoverLabel: `AI-organized attributes for ${newObjectName}`,\n          category: \"object\",\n          harmonizedAttributes: []\n        };\n      }\n    } else if (index < 5) {\n      // Debug the first few attributes without values\n      console.log(`Attribute ${index} (${attr.label}) has no new_object value`);\n      if (foundNewObjectKey) {\n        console.log(`  Value for \"${foundNewObjectKey}\": \"${attr[foundNewObjectKey]}\"`);\n      }\n    }\n  });\n  console.log(`Found ${attributesWithNewObject} attributes with new_object values out of ${attributes.length} total`);\n  console.log(`Unique new_object values: ${Array.from(newObjectValues).join(\", \")}`);\n  console.log(`Created objects based on new_object values: ${Object.keys(newObjectsMap).join(\", \")}`);\n\n  // If no new objects found, create fallback groupings\n  if (Object.keys(newObjectsMap).length === 0) {\n    console.log(\"No new object mappings found in data. Creating default fallback groups.\");\n\n    // Default object - just use Transformator\n    const defaultGroups = [\"Transformator\"];\n    defaultGroups.forEach((groupName, index) => {\n      const objectKey = `fallback-object-${index}`;\n      newObjectsMap[groupName] = {\n        key: objectKey,\n        label: groupName,\n        hoverLabel: `Default AI grouping for ${groupName.toLowerCase()} attributes`,\n        category: \"object\",\n        harmonizedAttributes: []\n      };\n    });\n\n    // Assign attributes to default groups\n    attributes.forEach(attr => {\n      // Always use Transformator since that's the only group\n      const targetGroup = defaultGroups[0];\n      const harmonizedName = attr.harmonisedAttribute || `Harmonised-${attr.label}`;\n\n      // Find original object\n      const originalObjectKey = links.filter(link => link.to === attr.key).map(link => link.from)[0];\n      const originalObjects = nodes.filter(node => node.category === \"object\");\n      const originalObject = originalObjectKey ? originalObjects.find(obj => obj.key === originalObjectKey) : null;\n      addAttributeToNewObject(newObjectsMap[targetGroup], attr, harmonizedName, (originalObject === null || originalObject === void 0 ? void 0 : originalObject.label) || \"Unknown\");\n    });\n  } else {\n    // Process attributes and add them to their appropriate new objects\n    attributes.forEach(attr => {\n      const harmonizedName = attr.harmonisedAttribute || `Harmonised-${attr.label}`;\n\n      // Find original object the attribute belonged to\n      const originalObjectKey = links.filter(link => link.to === attr.key).map(link => link.from)[0];\n      const originalObjects = nodes.filter(node => node.category === \"object\");\n      const originalObject = originalObjectKey ? originalObjects.find(obj => obj.key === originalObjectKey) : null;\n\n      // Get new_object value using the previously found key\n      let newObjectValue = null;\n      if (foundNewObjectKey && attr[foundNewObjectKey]) {\n        newObjectValue = attr[foundNewObjectKey];\n      } else {\n        for (const key of newObjectKeys) {\n          if (attr.hasOwnProperty(key) && attr[key] && attr[key].trim() !== '') {\n            newObjectValue = attr[key];\n            break;\n          }\n        }\n      }\n\n      // Determine target object (use new_object field or fallback)\n      const targetObjectName = newObjectValue && typeof newObjectValue === 'string' && newObjectValue.trim() !== '' ? newObjectValue.trim() : \"Other\";\n\n      // Ensure \"Other\" category exists if needed\n      if (targetObjectName === \"Other\" && !newObjectsMap[\"Other\"]) {\n        const objectKey = `new-object-other`;\n        newObjectsMap[\"Other\"] = {\n          key: objectKey,\n          label: \"Other\",\n          hoverLabel: \"Attributes not assigned to a specific object\",\n          category: \"object\",\n          harmonizedAttributes: []\n        };\n      }\n\n      // Add to appropriate new object\n      const targetObject = newObjectsMap[targetObjectName] || newObjectsMap[\"Other\"];\n      if (targetObject) {\n        addAttributeToNewObject(targetObject, attr, harmonizedName, (originalObject === null || originalObject === void 0 ? void 0 : originalObject.label) || \"Unknown\");\n      }\n    });\n  }\n\n  // Convert objects map to array and filter out empty objects\n  const objectsArray = Object.values(newObjectsMap).filter(obj => obj.harmonizedAttributes.length > 0);\n\n  // Sort objects and their attributes\n  objectsArray.sort((a, b) => a.label.localeCompare(b.label));\n  objectsArray.forEach(obj => {\n    obj.harmonizedAttributes.sort((a, b) => a.name.localeCompare(b.name));\n  });\n\n  // Create a single cluster containing all new objects\n  const aiGeneratedCluster = {\n    key: \"ai-generated-cluster\",\n    label: \"AI-Generated Structure\",\n    category: \"system\",\n    hoverLabel: \"Objects reorganized based on attribute relationships\",\n    objects: objectsArray\n  };\n  return objectsArray.length > 0 ? [aiGeneratedCluster] : [];\n}\n\n/**\r\n * Helper function to add an attribute to a new object\r\n * @param {Object} targetObject - The object to add the attribute to\r\n * @param {Object} attribute - The attribute to add\r\n * @param {string} harmonizedName - The harmonized name of the attribute\r\n * @param {string} originalObjectName - The name of the original object\r\n */\nfunction addAttributeToNewObject(targetObject, attribute, harmonizedName, originalObjectName) {\n  // Check if this harmonized attribute is already in the target object\n  const existingAttr = targetObject.harmonizedAttributes.find(attr => attr.name === harmonizedName);\n\n  // Check if this attribute is 3NF compliant\n  const is3NFCompliant = attribute.hasOwnProperty('3nf_marker') ? attribute['3nf_marker'] === 'yes' : Math.random() > 0.5; // Simulate for demo if field is missing\n\n  if (existingAttr) {\n    // Add the original attribute name if not already present\n    if (!existingAttr.originalAttributes.includes(attribute.label)) {\n      existingAttr.originalAttributes.push(attribute.label);\n    }\n\n    // If any attribute is not 3NF compliant, mark the harmonized attribute as not 3NF\n    if (!is3NFCompliant) {\n      existingAttr.is3NF = false;\n    }\n\n    // Make sure we track that this was moved from its original object\n    existingAttr.moved = true;\n\n    // Keep track of original object if not already set\n    if (!existingAttr.originalObject) {\n      existingAttr.originalObject = originalObjectName;\n    }\n  } else {\n    // Create a new harmonized attribute entry\n    targetObject.harmonizedAttributes.push({\n      name: harmonizedName,\n      count: 1,\n      originalAttributes: [attribute.label],\n      is3NF: is3NFCompliant,\n      moved: true,\n      originalObject: originalObjectName\n    });\n  }\n}","map":{"version":3,"names":["organizeDataForAIRearrangement","data","nodeDataArray","linkDataArray","console","log","nodes","links","attributes","filter","node","category","length","sampleAttr","keys","Object","forEach","key","newObjectsMap","newObjectKeys","foundNewObjectKey","hasOwnProperty","attr","index","label","prop","value","attributesWithNewObject","newObjectValues","Set","newObjectValue","trim","add","newObjectName","objectKey","hoverLabel","harmonizedAttributes","Array","from","join","defaultGroups","groupName","toLowerCase","targetGroup","harmonizedName","harmonisedAttribute","originalObjectKey","link","to","map","originalObjects","originalObject","find","obj","addAttributeToNewObject","targetObjectName","targetObject","objectsArray","values","sort","a","b","localeCompare","name","aiGeneratedCluster","objects","attribute","originalObjectName","existingAttr","is3NFCompliant","Math","random","originalAttributes","includes","push","is3NF","moved","count"],"sources":["C:/Users/R40008/Asset Model Server/python/bim-ai-poc/frontend/src/components/TableGraphVisualization/utils/dataOrganizer.js"],"sourcesContent":["/**\r\n * Reorganizes the graph data based on \"new_object\" attribute in CSV\r\n * @param {Object} data - The raw graph data\r\n * @returns {Array} - Array of reorganized objects\r\n */\r\nexport function organizeDataForAIRearrangement(data) {\r\n  if (!data || !data.nodeDataArray || !data.linkDataArray) {\r\n    console.log(\"No data available for AI rearrangement\");\r\n    return [];\r\n  }\r\n  \r\n  const { nodeDataArray: nodes, linkDataArray: links } = data;\r\n  const attributes = nodes.filter(node => node.category === \"attribute\");\r\n  \r\n  console.log(`Total number of attributes: ${attributes.length}`);\r\n\r\n  // For debugging - check what properties are available in the first few attributes\r\n  if (attributes.length > 0) {\r\n    const sampleAttr = attributes[0];\r\n    const keys = Object.keys(sampleAttr);\r\n    console.log(\"First attribute properties:\", keys);\r\n    console.log(\"First attribute sample:\", sampleAttr);\r\n    \r\n    // Show the actual properties and values\r\n    console.log(\"Property details:\");\r\n    keys.forEach(key => {\r\n      console.log(`  \"${key}\": \"${sampleAttr[key]}\"`);\r\n    });\r\n  } else {\r\n    console.log(\"No attributes found in data\");\r\n  }\r\n  \r\n  // Create a map of new objects based on the new_object field in attributes\r\n  const newObjectsMap = {};\r\n  \r\n  // Check for various forms of the new_object column\r\n  const newObjectKeys = [\"new_object\", \"new_object \", \"newobject\", \"NewObject\"];\r\n  let foundNewObjectKey = null;\r\n  \r\n  // Find which key is present in the attributes\r\n  if (attributes.length > 0) {\r\n    const sampleAttr = attributes[0];\r\n    for (const key of newObjectKeys) {\r\n      if (sampleAttr.hasOwnProperty(key)) {\r\n        foundNewObjectKey = key;\r\n        console.log(`Found new_object key as: \"${key}\" with value: \"${sampleAttr[key]}\"`);\r\n        break;\r\n      }\r\n    }\r\n    \r\n    if (!foundNewObjectKey) {\r\n      console.log(\"Could not find any new_object key. Available keys:\", Object.keys(sampleAttr));\r\n    }\r\n  }\r\n  \r\n  // Attempt to find ANY property that might have values like \"Transformator\"\r\n  attributes.forEach((attr, index) => {\r\n    if (index < 10) { // Check just the first 10 attributes\r\n      console.log(`Examining attribute ${index}: ${attr.label}`);\r\n      for (const prop in attr) {\r\n        const value = attr[prop];\r\n        if (typeof value === 'string') {\r\n          console.log(`  Property \"${prop}\" has string value: \"${value}\"`);\r\n        }\r\n      }\r\n    }\r\n  });\r\n  \r\n  // Count attributes with new_object values\r\n  let attributesWithNewObject = 0;\r\n  const newObjectValues = new Set();\r\n  \r\n  attributes.forEach((attr, index) => {\r\n    let newObjectValue = null;\r\n    \r\n    // Try the found key first\r\n    if (foundNewObjectKey && attr[foundNewObjectKey]) {\r\n      newObjectValue = attr[foundNewObjectKey];\r\n    } else {\r\n      // Otherwise try all possible variations\r\n      for (const key of newObjectKeys) {\r\n        if (attr.hasOwnProperty(key) && attr[key] && attr[key].trim() !== '') {\r\n          newObjectValue = attr[key];\r\n          if (!foundNewObjectKey) foundNewObjectKey = key;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n    \r\n    if (newObjectValue && typeof newObjectValue === 'string' && newObjectValue.trim() !== '') {\r\n      // Sample the first few values for debugging\r\n      if (index < 5) {\r\n        console.log(`Attribute ${index} (${attr.label}) has \"${foundNewObjectKey}\" value: \"${newObjectValue}\"`);\r\n      }\r\n      \r\n      attributesWithNewObject++;\r\n      newObjectValues.add(newObjectValue.trim());\r\n      \r\n      const newObjectName = newObjectValue.trim();\r\n      \r\n      if (!newObjectsMap[newObjectName]) {\r\n        const objectKey = `new-object-${Object.keys(newObjectsMap).length + 1}`;\r\n        newObjectsMap[newObjectName] = {\r\n          key: objectKey,\r\n          label: newObjectName,\r\n          hoverLabel: `AI-organized attributes for ${newObjectName}`,\r\n          category: \"object\",\r\n          harmonizedAttributes: []\r\n        };\r\n      }\r\n    } else if (index < 5) {\r\n      // Debug the first few attributes without values\r\n      console.log(`Attribute ${index} (${attr.label}) has no new_object value`);\r\n      if (foundNewObjectKey) {\r\n        console.log(`  Value for \"${foundNewObjectKey}\": \"${attr[foundNewObjectKey]}\"`);\r\n      }\r\n    }\r\n  });\r\n  \r\n  console.log(`Found ${attributesWithNewObject} attributes with new_object values out of ${attributes.length} total`);\r\n  console.log(`Unique new_object values: ${Array.from(newObjectValues).join(\", \")}`);\r\n  console.log(`Created objects based on new_object values: ${Object.keys(newObjectsMap).join(\", \")}`);\r\n\r\n  // If no new objects found, create fallback groupings\r\n  if (Object.keys(newObjectsMap).length === 0) {\r\n    console.log(\"No new object mappings found in data. Creating default fallback groups.\");\r\n    \r\n    // Default object - just use Transformator\r\n    const defaultGroups = [\"Transformator\"];\r\n    defaultGroups.forEach((groupName, index) => {\r\n      const objectKey = `fallback-object-${index}`;\r\n      newObjectsMap[groupName] = {\r\n        key: objectKey,\r\n        label: groupName,\r\n        hoverLabel: `Default AI grouping for ${groupName.toLowerCase()} attributes`,\r\n        category: \"object\",\r\n        harmonizedAttributes: []\r\n      };\r\n    });\r\n    \r\n    // Assign attributes to default groups\r\n    attributes.forEach(attr => {\r\n      // Always use Transformator since that's the only group\r\n      const targetGroup = defaultGroups[0]; \r\n      const harmonizedName = attr.harmonisedAttribute || `Harmonised-${attr.label}`;\r\n      \r\n      // Find original object\r\n      const originalObjectKey = links\r\n        .filter(link => link.to === attr.key)\r\n        .map(link => link.from)[0];\r\n      \r\n      const originalObjects = nodes.filter(node => node.category === \"object\");\r\n      const originalObject = originalObjectKey ? \r\n        originalObjects.find(obj => obj.key === originalObjectKey) : null;\r\n      \r\n      addAttributeToNewObject(\r\n        newObjectsMap[targetGroup],\r\n        attr,\r\n        harmonizedName,\r\n        originalObject?.label || \"Unknown\"\r\n      );\r\n    });\r\n  } else {\r\n    // Process attributes and add them to their appropriate new objects\r\n    attributes.forEach(attr => {\r\n      const harmonizedName = attr.harmonisedAttribute || `Harmonised-${attr.label}`;\r\n      \r\n      // Find original object the attribute belonged to\r\n      const originalObjectKey = links\r\n        .filter(link => link.to === attr.key)\r\n        .map(link => link.from)[0];\r\n      \r\n      const originalObjects = nodes.filter(node => node.category === \"object\");\r\n      const originalObject = originalObjectKey ? \r\n        originalObjects.find(obj => obj.key === originalObjectKey) : null;\r\n      \r\n      // Get new_object value using the previously found key\r\n      let newObjectValue = null;\r\n      \r\n      if (foundNewObjectKey && attr[foundNewObjectKey]) {\r\n        newObjectValue = attr[foundNewObjectKey];\r\n      } else {\r\n        for (const key of newObjectKeys) {\r\n          if (attr.hasOwnProperty(key) && attr[key] && attr[key].trim() !== '') {\r\n            newObjectValue = attr[key];\r\n            break;\r\n          }\r\n        }\r\n      }\r\n      \r\n      // Determine target object (use new_object field or fallback)\r\n      const targetObjectName = (newObjectValue && typeof newObjectValue === 'string' && newObjectValue.trim() !== '')\r\n        ? newObjectValue.trim()\r\n        : \"Other\";\r\n      \r\n      // Ensure \"Other\" category exists if needed\r\n      if (targetObjectName === \"Other\" && !newObjectsMap[\"Other\"]) {\r\n        const objectKey = `new-object-other`;\r\n        newObjectsMap[\"Other\"] = {\r\n          key: objectKey,\r\n          label: \"Other\",\r\n          hoverLabel: \"Attributes not assigned to a specific object\",\r\n          category: \"object\",\r\n          harmonizedAttributes: []\r\n        };\r\n      }\r\n      \r\n      // Add to appropriate new object\r\n      const targetObject = newObjectsMap[targetObjectName] || newObjectsMap[\"Other\"];\r\n      \r\n      if (targetObject) {\r\n        addAttributeToNewObject(\r\n          targetObject,\r\n          attr,\r\n          harmonizedName,\r\n          originalObject?.label || \"Unknown\"\r\n        );\r\n      }\r\n    });\r\n  }\r\n  \r\n  // Convert objects map to array and filter out empty objects\r\n  const objectsArray = Object.values(newObjectsMap)\r\n    .filter(obj => obj.harmonizedAttributes.length > 0);\r\n  \r\n  // Sort objects and their attributes\r\n  objectsArray.sort((a, b) => a.label.localeCompare(b.label));\r\n  objectsArray.forEach(obj => {\r\n    obj.harmonizedAttributes.sort((a, b) => a.name.localeCompare(b.name));\r\n  });\r\n  \r\n  // Create a single cluster containing all new objects\r\n  const aiGeneratedCluster = {\r\n    key: \"ai-generated-cluster\",\r\n    label: \"AI-Generated Structure\",\r\n    category: \"system\",\r\n    hoverLabel: \"Objects reorganized based on attribute relationships\",\r\n    objects: objectsArray\r\n  };\r\n  \r\n  return objectsArray.length > 0 ? [aiGeneratedCluster] : [];\r\n}\r\n\r\n/**\r\n * Helper function to add an attribute to a new object\r\n * @param {Object} targetObject - The object to add the attribute to\r\n * @param {Object} attribute - The attribute to add\r\n * @param {string} harmonizedName - The harmonized name of the attribute\r\n * @param {string} originalObjectName - The name of the original object\r\n */\r\nfunction addAttributeToNewObject(targetObject, attribute, harmonizedName, originalObjectName) {\r\n  // Check if this harmonized attribute is already in the target object\r\n  const existingAttr = targetObject.harmonizedAttributes.find(attr => \r\n    attr.name === harmonizedName\r\n  );\r\n  \r\n  // Check if this attribute is 3NF compliant\r\n  const is3NFCompliant = attribute.hasOwnProperty('3nf_marker') \r\n    ? attribute['3nf_marker'] === 'yes'\r\n    : Math.random() > 0.5; // Simulate for demo if field is missing\r\n  \r\n  if (existingAttr) {\r\n    // Add the original attribute name if not already present\r\n    if (!existingAttr.originalAttributes.includes(attribute.label)) {\r\n      existingAttr.originalAttributes.push(attribute.label);\r\n    }\r\n    \r\n    // If any attribute is not 3NF compliant, mark the harmonized attribute as not 3NF\r\n    if (!is3NFCompliant) {\r\n      existingAttr.is3NF = false;\r\n    }\r\n    \r\n    // Make sure we track that this was moved from its original object\r\n    existingAttr.moved = true;\r\n    \r\n    // Keep track of original object if not already set\r\n    if (!existingAttr.originalObject) {\r\n      existingAttr.originalObject = originalObjectName;\r\n    }\r\n  } else {\r\n    // Create a new harmonized attribute entry\r\n    targetObject.harmonizedAttributes.push({\r\n      name: harmonizedName,\r\n      count: 1,\r\n      originalAttributes: [attribute.label],\r\n      is3NF: is3NFCompliant,\r\n      moved: true,\r\n      originalObject: originalObjectName\r\n    });\r\n  }\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}